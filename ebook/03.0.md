# 3 函数调用协议

理解Go的函数调用协议对于研究其内部实现非常重要。这里将会介绍Go进行函数调用时的内存布局，参数传递和返回值的约定。正如C和汇编都是同一套约定所以能相互调用一样，Go和C以及汇编也是要满足某些约定才能够相互调用。

本章先从Go调用C和汇编的例子开始(非cgo方式)，通过分析其实现学习Go的函数调用协议。然后将会研究go和defer关键字等神奇的魔法。最后会研究分裂栈的实现。这一章的内容将是后面研究cgo，goroutine实现的基础。分裂栈技术是Go能够开千千万万条“线程”而不耗尽内存的基本保证，也为cgo带来了很大的限制，这些将会在后面章节中再讨论。

小知识点：Go是从plan9过来的，其作者rob pike等正是搞plan9的那波人。所以Go中使用的C语言以及编译器更多的是plan9操作系统那边的一些基因。plan9编译器采用是"caller save"，调用者保存寄存器。被调者可以使用任何寄存器而不必保存它们。这是和我们平时使用的C编译器一个不一样的地方。

Go中没有用栈基址寄存器ebp，因为它用的是非连续栈，实现上是用stack_base和stack_guard来标识一个栈，保存在struct G中。好，让我们进入正题吧！

## links
  * [目录](<preface.md>)
  * 上一节：[map的实现](<02.2.md>)
  * 下一节: [Go调用汇编和C](<03.1.md>)

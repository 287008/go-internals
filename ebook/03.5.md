# 3.5 分裂栈

Go语言中使用的是栈不是连续的，原因是需要支持goroutine。假如每个goroutine分配固定栈大小并且不能增长，太小则会导致溢出，太大又会浪费空间，无法开许多的goroutine。分段栈的重要意义就在于，可以初始时只给栈分配很小的空间，然后随着使用过程中的需要自动地增长。这就是为什么Go可以开千千万万个goroutine而不会耗尽内存。

## 基本原理
为了便于理解，可以拿操作系统中的分页和Go语言的分裂栈进行类比。在操作系统中，每个进程可以使用整个地址空间，并不会感觉到它使用的内存是一页一页不连续的。其原理就在于操作系统会处理好底层的细节使得上层看起来像是一个逻辑上连续的内存空间。假如进程访问到一个逻辑地址，该地址还没有给它分配物理内存，则这时会发生缺页中断。操作系统会把发生中断时的上下文保存下来，然后为进程分配一页大小的物理内存，设置好映射关系，最后恢复中断发生前的上下文。进程继续运行时，并不会感觉到缺页中断的整个过程。

分裂栈也是很类似的。当栈的大小不够用时，会触发“中断”，从当前函数进入到Go的运行时库，Go的运行时会保存此时的函数上下文环境，然后分配一个新的足够大的栈空间，并做一些设置，使得当函数恢复时，它会在新分配的栈中继续执行，仿佛整个过程都没发生过一样，这个函数会觉得自己使用的是一块大小“无限”的连续栈空间。

## 实现过程
在研究Go的实现细节之前让我们先思考一下如果让我们实现会怎么做。第一步肯定要有某种机制检测到当前栈大小不够用了，这个应该是把当前的栈寄存器SP跟可用空间的边界进行比较。能够检测到栈大小不够用，就相当于捕捉到了“中断”。那么第二步要做的，就应该是进入运行时，保存当前的上下文。假如我们把函数栈分裂时的上下文保存好了，那下一步就是分配新的栈空间了。

接下来怎么办呢？如何让函数在新的栈中继续运行，好像没发生过栈分裂一样？可能很多人会卡在这一步了。

## 具体细节
((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((跟代码的方式)
   ％gs寄存器存一个tcb结构的地址，go语言中是G这个结构体．这个结构中存了栈基址和stack\_guard

   对于使用分段栈的函数，每次进入函数后，前几条指令就是先检测%esp跟stack\_guard比较，如果超了就要扩展栈空间

** 扩展栈
   所有用于分配栈空间的函数本身不能使用分段栈．引入一个属性来控制函数的生成．当然，还要保证有足够的空间来调用分配函数。编译器在编译阶段加入特殊的标识.note.GNU-split-stack，链接时对于检测到有这些标签的函数，就会插入特殊指令。扩展完之后，使用新栈之间，需要一些处理

   基于原栈%esp的数据都可以直接复制到新栈中来．对于栈中存的是对象的地址，这样做不会造成问题。对于带参函数，因为参数不能直接搬，编译时要特殊处理．函数使用的参数指针不是基于栈帧的．对于在栈中返回对象的函数，对象必须返回到原栈上

   扩展栈时，函数的返回地址会被修改成一个函数，这个函数会释放分配的栈块，将栈指针重新设置成调用者旧栈块的地址，栈指针等，需要在新栈空间中的某处保存着．
 http://gcc.gnu.org/wiki/SplitStacks
** 兼容性
   GCC中使用split栈的函数，编译split栈的函数，会加入.note.GNU-split-stack信息．链接时如果有这些东西，就会链接上split栈的相关runtime库.在gcc实现的split栈中要hack　exit函数以便最后退出时处理这些分裂栈空间．
** go语言中的具体实现
  go语言使用的就是分段栈，这样可以起很多个goroutine.
  http://blog.nella.org/?p=849

## 实战探索

```go  
	package main

	func main() {
		main()
	}
```

```sh
	go tool 6g -S test.go | head -10
```

```sh
	go tool 6g -a test.6 | head -10
```

分裂栈是在链接过程中实现的，而不是在编译过程中实现的。哇，跟go和defer关键字一样的精妙！不必在编译层做修改，没有打破原有的协议。

b runtime.morestack
r
bt
disas
info reg
x 0xb7dc3000

但是Go中的有些函数是不能检测栈溢出的，所以必须保留一定的空间确定它们能运行。
  编译标记7
  如果你读源代码，可能会发现"#pragma textflag 7"，或者在汇编函数中看到"TEXT reuntime.exit(SB),7,$0"，这种函数就是不会检测栈溢出的。
  汇编或者编译器中的标记7让链接器不要加入栈溢出检测。

  然后让我们看看runtime/asm_amd64.s。有两点信息要注意：第一点是morestack将一些信息存在struct M中，这些信息包括当前栈桢，参数，当前函数调用，函数返回地址，（两个返回地址，一个是runtime.morestack的函数地址，一个是f的返回地址）。通过这些信息可以把新栈和旧栈链起来。

  切换到调度器栈，将控制流交给runtime.newstack。这里的分配机制跟Go的运行时的分配机制是一样的，所以要注意给runtime.mallocgc留足够的空间保证它能运行。

  newstack中有很大一部分跟reflect相关的代码，现在先不管它。newstack做的事情很容易看明白：分配新栈空间，在该空间顶部初始化一个struct Stktop的东西，然后以很奇特的方式退出。
  
  不是所有栈的内存都从垃圾回收的池子中来和去的。

  lessstack在旧栈的上下文中运行。它做的事情是保存，并准备好调用旧栈的环境。需要保存返回值，然后切换到调度器栈，原因跟morestack相同。它也以gogo的方式退出。

  想一想，如果morestack在返回到旧栈之前，被调用了两次会发生什么事情？
  
  这个上面讲的gcc怎么实现splitstack的，其作者正是gccgo的作者．在go语言的实现中其实思想和方法跟上面都是一致的．

  进入函数后的前几条指令就是取%gs到%ecb  这时获得了结构体G的地址．这个结构体前两个域就是stackguard和stackbase

  我还观察到，好象go编译的程序，没有使用%ebp，可能是因为G中已经存的栈基址的缘故.检测stackguard和%esp，如果空间不够了就会调用到runtime.morestack.这是一个汇编函数，在asm_386.s文件中可以找到

  #+begin_quote
  TEXT runtime.morestack (SB),7,$0 
  #+end_quote
  其中这个7就是告诉编译器这个函数不使用分段栈\\
  runtime.morestack会把一些信息存到结构体M\\
  DX中是frame size, AX中是arg size，这些会被保存到M结构体，还有函数返回地址，保存以后这些东西在后面会清空，然后新栈和旧栈信息可以link起来．

  当morestack函数保存好需要的东西以后，它切换到调度器的栈，然后将控制器交给runtime.newstack

  注意调用到runtime.newstack的方式是CALL，并且用的是调度器的栈，函数的退出有点特殊．

  栈空间的分配使用的普通的go runtime的空间分配技术，也就是会垃圾回收．但也有些特殊，也不完全是直接从垃圾回收的池子中来，回来垃圾回收的池子中去．

  runtime.newstack不会返回到调用者morestack.不考虑reflect相关的东西，它做的事情就是分配一块内存，在头部放一个Stktop的结构体，特殊方式退出．\\
  清除栈时，新栈中保存的这些栈桢的信息会起作用．

  退出使用的是gogocall，是调度器实现上下文切换上函数．相当于直接jump过去的而不是函数调用协议那样过去的．保存的函数返回地址被设置为一个后处理的函数，这样遇到下一次RET指令时，会jump到more.lessstack函数，这个函数做的正好是跟morestack函数相反的工作．然后就到新栈中去工作了．

  再重复一遍整个过程：
1. 使用分段栈的函数头几个指令检测%esp和stackguard，调用于runtime.morestack
2. runtime.more函数的主要功能是保存当前的栈的一些信息．然后转换成调试器的栈了调用runtime.newstack
3. runtime.newstack函数的主要功能是分配空间，装饰此空间，将旧的frame和arg弄到新空间
4. 使用gogocall的方式切换到新分配的栈，gogocall使用的JMP返回到被中断的函数
5. 继续执行遇到RET指令时会返回到runtime.less，less做的事情跟more相反，它要准备好从newstack到old　stack
  整个过程有点像一次中断，中断处理时保存当时的现场，弄个新的栈，中断恢复时恢复到新栈中运行，运行到return时又要从runtime.less走回去


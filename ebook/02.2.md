# 2.2 slice

slice是一块数组区域的引用。在内存表示上，它就是一个包含3个成员的结构体，分别是一个指针首个数组元素的指针，区域的长度，以及区域的容量。区域长度限定了像x[i]这种索引操作的边界，而区域容量是像x[i:j]这种slice操作的边界。

![](http://research.swtch.com/godata3.png)

数组的slice并不会实际复制一份数据，它只是创建一个新的数据结构，包含了另外的一个指针，一个长度和一个容量数据。

其实slice在Go的运行时库中就是一个C语言动态数组的实现，在$GOROOT/src/pkg/runtime/runtime.h中可以看到它的定义：

```go
	struct	Slice
	{				// must not move anything
		byte*	array;		// actual data
		uintgo	len;		// number of elements
		uintgo	cap;		// allocated number of elements
	};
```


Like slicing a string, slicing an array does not make a copy: it only creates a new structure holding a different pointer, length, and capacity. In the example, evaluating the composite literal []int{2, 3, 5, 7, 11} creates a new array containing the five values and then sets the fields of the slice x to describe that array. The slice expression x[1:3] does not allocate more data: it just writes the fields of a new slice structure to refer to the same backing store. In the example, the length is 2—y[0] and y[1] are the only valid indexes—but the capacity is 4—y[0:4] is a valid slice expression. (See Effective Go for more about length and capacity and how slices are used.)

Because slices are multiword structures, not pointers, the slicing operation does not need to allocate memory, not even for the slice header, which can usually be kept on the stack. This representation makes slices about as cheap to use as passing around explicit pointer and length pairs in C. Go originally represented a slice as a pointer to the structure shown above, but doing so meant that every slice operation allocated a new memory object. Even with a fast allocator, that creates a lot of unnecessary work for the garbage collector, and we found that, as was the case with strings above, programs avoided slicing operations in favor of passing explicit indices. Removing the indirection and the allocation made slices cheap enough to avoid passing explicit indices in most cases.

## slice的扩容
在对slice进行append等操作时，可能会造成slice的自动扩容。其扩容时的大小增长规则是：

- 如果新的大小是当前大小2倍以上，则大小增长为新大小
- 否则，如果当前大小小于1024个，按每次2倍增长。
- 否则，按每次是上一次大小的1.25倍增长

在slice.c中可以看到其源代码:

```c
	static void
	growslice1(SliceType *t, Slice x, intgo newcap, Slice *ret)
	{
		intgo m;

		m = x.cap;
		if(m+m < newcap)
			m = newcap;
		else {
			do {
				if(x.len < 1024)
					m += m;
				else
					m += m/4;
			} while(m < newcap);
		}
		makeslice1(t, x.len, m, ret);
		runtime·memmove(ret->array, x.array, ret->len * t->elem->size);
	}
```

注意make的参数是intgo，它是一个带符号的整型，在32位机器上它是32位的，在64位机器上是64位的。

## make和new
Go有两个数据结构创建函数：new和make。两者的区别在学习的初期是一个常见的混淆点，但这个问题很快就可以迎刃而解。基本的区别是new(T)返回一个*T，返回的这个指针可以被隐式地消除引用（图中的黑色箭头）。而make(T, args)返回一个普通的T。通常情况下，T内部有一些隐式的指针（图中的灰色箭头）。一句话，new返回一个指向已清零内存的指针，而make返回一个复杂的结构。

![](http://research.swtch.com/godata3.png)

有一种方法可以统一这两种创建方式，但是可能会与C/C++的传统有显著不同：定义make(*T)来返回一个指向新分配的T的指针，这样一来，new(Point)得写成make(*Point)。我们这样做了几天就放弃了--实在是和人们期望的分配函数太不一样了。

## links
   * [目录](<preface.md>)
   * 上一节: [基本类型](<02.1.md>)
   * 下一节: [map](<02.3.md>)

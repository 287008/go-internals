# 7.1 channel

## channel数据结构
Go语言channel是first-class的，也就是它可以被作为参数传递给函数，可以作为函数的返回值返回。作为Go语言的核心特征之一，虽然channel看上去很高端，但是其实channel仅仅就是一个数据结构而已，结构体定义如下：

```c
struct	Hchan
{
	uintgo	qcount;			// 队列q中的总数据数量
	uintgo	dataqsiz;		// 环形队列q的数据大小
	uint16	elemsize;
	bool	closed;
	uint8	elemalign;
	Alg*	elemalg;		// interface for element type
	uintgo	sendx;			// 发送index
	uintgo	recvx;			// 接收index
	WaitQ	recvq;			// 因recv而阻塞的等待队列
	WaitQ	sendq;			// 因send而阻塞的等待队列
	Lock;
};
```

让我们来看一个Hchan这个结构体。其中一个核心的部分是存放channel数据的环形队列，由qcount和elemsize分别指定了队列的容量和当前使用量。dataqsize是队列的大小。elemalg是元素操作的一个Alg结构体，记录下元素的操作，如copy函数，equal函数，hash函数等。


可能会有人疑惑，结构体中只看到了队列大小相关的域，并没有看到存放数据的域啊？如果是带缓冲区的chan，则缓冲区数据实际上是接着Hchan结构体中分配的。

```c
c = (Hchan*)runtime.mal(n + hint*elem->size);
```

另一个重要部分就是recvq和sendq两个链表，一个是因读这个通道而导致阻塞的goroutine，另一个是因为写这个通道而阻塞的goroutine。如果一个goroutine阻塞于channel了，那么它就被挂在recvq或sendq中。WaitQ是链表的定义，包含一个头结点和一个尾结点：

```c
struct	WaitQ
{
	SudoG*	first;
	SudoG*	last;
};
```

队列中的每个成员是一个SudoG结构体变量。

```c
struct	SudoG
{
	G*	g;		// g and selgen constitute
	uint32	selgen;		// a weak pointer to g
	SudoG*	link;
	int64	releasetime;
	byte*	elem;		// data element
};
```

 该结构中主要的就是一个g和一个elem。elem用于存储goroutine的数据。读通道时，数据会从Hchan的队列中拷贝到SudoG的elem域。写通道时，数据则是由SudoG的elem域拷贝到Hchan的队列中。

Hchan结构如下图所示(补图):

## 读写channel操作


   以runtime.chansend为例来看向chan中写数据的过程.

   先要区分是同步还是异步.同步是指chan是不带缓冲区的,因此可能写阻塞.而异步是指chan带缓冲区,只有缓冲区满才阻塞.
   同步的情况,首先会看recvq中有没有因读该管道而阻塞的goroutine,如果有,则把数据拷贝到它的elem中,将它置为ready,然后函数返回.
   否则要将当前goroutine和数据作为SudoG结构体,挂到通道的阻塞队列中.

   异步的情况,如果缓冲区满了,也是要将当前goroutine和数据一起作为SudoG结构体挂在sendq队列中的.
   否则也是先看有没有recvq,有就唤醒.没有就将数据放到通过的缓冲区中.
   
runtime.chanrecv跟chansend一个样子的.只不过一个是收一个是发.

特殊通道操作--空通道，关闭通道

## select的实现


select-case被中的chan编译成了if-else.比如
``c
select {
case v = <-c:
        ...foo
default:
        ...bar
}
```
会被编译为:
```c
if selectnbrecv(&v, c) {
        ...foo
} else {
        ...bar
}
```

类似地
```c
select {
case v, ok = <-c:
	... foo
default:
	... bar
}
```
会被编译为:
```c
if c != nil && selectnbrecv2(&v, &ok, c) {
	... foo
} else {
	... bar
}
```
select-case中的case是随机的.而不像switch-case那样一条一条的顺序.如何实现随机的呢?
其实上面用到了Scase和Select数据结构.在Select数据结构中有个Scase数组,记录下了每一个Scase.
然后将数组元素随机排列,这样就可以将Scase乱序了.

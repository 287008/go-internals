# 3.1 Go调用汇编和C
只要不使用C的标准库函数，Go中是可以直接调用C和汇编语言的。其实道理很简单，Go的运行时库就是用C和汇编实现的，Go必须是能够调用到它们的。当然，会有一些额外的约束，这就是函数调用协议。

## Go中调用汇编
假设我们做一个汇编版本的加法函数。首先GOPATH的src下新建一个add目录，然后在该目录加入add.go的文件，内容如下：

```go
	package add

	func Add(a, b uint64) uint64 {
		return a+b
	}
```

这个函数将两个uint64的数字相加，并返回结果。我们写一个简单的函数调用它，内容如下：

```go
	package main

	import (
	  "fmt"
	  "add"
	)

	func main() {
	     fmt.Println(add.Add(2, 15))
	}
```

可以看到输出了结果为17。好的，接下来让我们删除Add函数的实现，只留下定义部分：

```go
	package add

	func Add(a, b uint64) uint64
```

然后在add.go同一目录中建立一个add_amd64.s的文件(假设你使用的是64位系统)，内容如下：

```asm
	TEXT    ·Add+0(SB),$0-24
	MOVQ    a+0(FP),BX
	MOVQ    b+8(FP),BP
	ADDQ    BP,BX
	MOVQ    BX,res+16(FP)
	RET     ,
```

虽然汇编是相当难理解的，但我相信读懂上面这段不会有困难。前两条MOVQ指令分别将第一个参数放到寄存器BX，第二个参数放到寄存器BP，然后ADDQ指令将两者相加后，最后的MOVQ和RET指令返回结果。

现在，再次运行前面的main函数，它将使用自定义的汇编版本函数，可以看到成功的输出了结果17。从这个例子中可以看出Go是可以直接调用汇编实现的函数的。大多时候不必要你去写汇编，即使是研究Go的内部实现，能读懂汇编已经很足够了。

也许你真的觉得在Go中写汇编很酷，但是不要忽视了这些忠告：

- 汇编很难编写，特别是很难写好。通常编译器会比你写出更快的代码。
- 汇编仅能运行在一个平台上。在这个例子中，代码仅能运行在 amd64 上。这个问题有一个解决方案是给 Go 对于 x86 和 arm 不同版本的代码（[像这样](../go/src/pkg/math)）。
- 汇编让你和底层绑定在一起，而标准的 Go 不会。例如，slice 的长度当前是 32 位整数。但是也不是不可能为长整型。当发生这些变化时，这些代码就被破坏了（也可能是编译器无法检测到的更恶心的途径来破坏）
当前 Go 编译器不能将汇编编译为函数的内联，但是对于小的 Go 函数是可以的。因此使用汇编可能意味着让你的程序更慢。

有时需要汇编给你带来一些力量（不论是性能方面的原因，还是一些相当特殊的关于 CPU 的操作）。对于什么时候应该使用它，Go 源码包括了若干相当好的例子（可以看看 crypto 和 math）。由于它非常容易实践，所以这绝对是个学习汇编的好途径。

## Go中调用C

## 函数调用时的内存布局
